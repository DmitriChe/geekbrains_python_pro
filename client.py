# Домашнее задание 03.
# Реализовать простое клиент-серверное взаимодействие по протоколу JIM (JSON instant messaging):
# клиент отправляет запрос серверу;
# сервер отвечает соответствующим кодом результата.
# Клиент и сервер должны быть реализованы в виде отдельных скриптов, содержащих соответствующие функции.
# Функции клиента:
#   - сформировать presence-сообщение;
#   - отправить сообщение серверу;
#   - получить ответ сервера;
#   - разобрать сообщение сервера;
#   - параметры командной строки скрипта client.py <addr> [<port>]: addr — ip-адрес сервера;
#   - port — tcp-порт на сервере, по умолчанию 7777.
# Функции сервера:
#   - принимает сообщение клиента;
#   - формирует ответ клиенту;
#   - отправляет ответ клиенту;
#   - имеет параметры командной строки: -p <port> — TCP-порт для работы (по умолчанию использует 7777);
#   - -a <addr> — IP-адрес для прослушивания (по умолчанию слушает все доступные адреса).


# pip install pyyaml
import yaml
import socket
from argparse import ArgumentParser


# На сервере и клиенте host и port должны совпадать - а как это обеспечить в независимых приложениях?
# Через файл config.yml
# А если файла не будет? А если его переименют?
# А для этого предусмотрим возможнось задавать его имя из командной строки при запуске приложения,
# а оттуда будем парсить настройки с помощью ArgumentParser

# Создание парсера командной строки для анализа запроса: python client.py -c config.yml
parser = ArgumentParser()
parser.add_argument(
    '-c', '--config', type=str,  # Описываем параметры (-c - сокращенное имя для командной строки или --config - полное имя, которое испльзуется далее в args.config) для командной строки и допустимый тип данных - str
    required=False,  # Задаем, что этот аргумент является необязательным
    help='Sets config file path'  # Сообщение при вызове помощи
)
parser.add_argument(
    '-a', '--addr', type=str,  # Описываем параметры (-c - сокращенное имя для командной строки или --config - полное имя, которое испльзуется далее в args.config) для командной строки и допустимый тип данных - str
    required=False,  # Задаем, что этот аргумент является необязательным
    help='Sets ip-адрес сервера'  # Сообщение при вызове помощи
)
parser.add_argument(
    '-p', '--port', type=int,  # Описываем параметры (-c - сокращенное имя для командной строки или --config - полное имя, которое испльзуется далее в args.config) для командной строки и допустимый тип данных - str
    required=False,  # Задаем, что этот аргумент является необязательным
    help='Sets tcp-порт сервера'  # Сообщение при вызове помощи
)

# Считываем аргументы из командной строки
args = parser.parse_args()

# Создадим словарь со знаениями по умолчанию - default configuration
# Т.е. если в командрой стоке не указан конфигурационный файл, в качестве параметра,
# а лишь python client.py, то берем данные отсюда:
config = {
    'host': 'localhost', # здесь используем локальный хост
    'port': 7777,  # номер порта на сетевой карте.
    'buffersize': 1024  # размер буфера для приема сообщений клиента
}

# Если в командной строке указали аргумент с config файлом, то берем данные оттуда и перезаписываем ими словарь config
if args.config:
    with open(args.config) as file:
        file_config = yaml.load(file, Loader=yaml.Loader)
        config.update(file_config)


# Вычленяем данные для подключения из config
host, port = config.get('host'), config.get('port')

# Если данные о подключени переданы в командной строке, то берем их оттуда
if args.addr:
    host = args.addr
if args.port:
    port = args.port
print(args.addr)
print(args.port)

# Обработчик ошибки KeyboardInterrupt при нажатии Ctrl+C, Ctrl+D, Ctrl+BackSpace
try:
    # Создадим клентскую адресную пару - хост и порт
    # Создаем объект socket - абстракцию над аппаратно-программной системой сетевой карты, драйверов, буферных файлов, софта, ip, port
    sock = socket.socket()
    # Подключаемся
    sock.connect((host, port))
    print(f'Client was started with { host }:{ port }\n')

    # Данные: ввод и вывод
    data = input('Enter data: ')
    # Кодируем и посылаем данные серверу
    sock.send(data.encode())
    print(f'Client send data { data }\n')

    b_response = sock.recv(config.get('buffersize'))
    print(f'Server send data {b_response.decode()}')  # деокдируем и выводим полученные данные

except KeyboardInterrupt:
    print('Client shotdown.')  # Вывод сообщения, что клиет завершил свое выполнение

# Список функций для сокетов
# Общие:
# socket - конструктор объекта сокета (с методами сединения). Сокет - программный интерфейс, позволяющий отправлть данные по сети. Пара буферых файлов для хранения передаваемых данных, ip, port, программный интерфейс, который все это обслуживает, драйвера сетевой.... OSI
# send - передать данные
# recv - получить данные
# close - закрыть соединение
# Серверные:
# bind - привязать сокет к IP-адресу и порту машины
# listen - просигнализировать о готовности принимать соедение (аргументом явл число возможных подключений)
# accept - подтверждение принятия запроса на устанговку соединения
# Клиентские:
# connect - установить соединение